#!/usr/bin/python3

import argparse
import contextlib
import json
import os
import subprocess
import sys
import tempfile


RESET = "\033[0m"
BOLD = "\033[1m"
RED = "\033[31m"


@contextlib.contextmanager
def tmpfs():
    """A contextmanager that mounts a tmpfs and returns its location.
    """

    with tempfile.TemporaryDirectory(prefix="osbuild-tree-", dir=os.getcwd()) as path:
        subprocess.run(["mount", "-t", "tmpfs", "tmpfs", path], check=True)
        try:
            yield path
        finally:
            subprocess.run(["umount", path], check=True)

@contextlib.contextmanager
def bindmnt(src_path):
    """A contextmanager that mindmounts a path read-only and returns its location.
    """

    with tempfile.TemporaryDirectory(prefix="osbuild-build-", dir=os.getcwd()) as dst_path:
        subprocess.run(["mount", "-o", "bind,ro", src_path, dst_path], check=True)
        try:
            yield dst_path
        finally:
            subprocess.run(["umount", dst_path], check=True)


def main(pipeline_path, input_dir, output_dir, sit):
    if output_dir and len(os.listdir(output_dir)) != 0:
        print()
        print(f"{RESET}{BOLD}{RED}Output directory {output_dir} is not empty{RESET}")
        return 1

    with open(pipeline_path) as f:
        pipeline = json.load(f)

    with tmpfs() as tree, bindmnt("/") as root:
        for i, stage in enumerate(pipeline["stages"], start=1):
            name = stage["name"]
            options = stage.get("options", {})
            options["tree"] = "/tmp/tree"

            # systemd-nspawn silently removes some characters when choosing a
            # machine name from the directory name. The only one relevant for
            # us is '_', because all other characters used by
            # TemporaryDirectory() are allowed. Replace it with 'L's
            # (TemporaryDirectory() only uses lower-case characters)
            machine_name = os.path.basename(root).replace("_", "L")

            argv = ["systemd-nspawn",
                    "--as-pid2",
                    "--link-journal=no",
                    "--volatile=yes",
                    f"--machine={machine_name}",
                    f"--directory={root}",
                    f"--bind={tree}:/tmp/tree",
                    f"--bind={os.getcwd()}/run-stage:/tmp/run-stage",
                    f"--bind={os.getcwd()}/stages/{name}:/tmp/stage",
                    "--bind=/etc/pki"]

            # Optionally pass the input dir to the first stage
            if input_dir:
                options["input_dir"] = "/tmp/input"
                argv.append(f"--bind-ro={os.getcwd()}/{input_dir}:/tmp/input")

            # Pass the tree r/w to all stages but the last one.
            # The last stage gets the tree ro and optionally gets an output dir
            if i == len(pipeline["stages"]) and output_dir:
                options["output_dir"] = "/tmp/output"
                argv.append(f"--bind={os.getcwd()}/{output_dir}:/tmp/output")

            argv.append("/tmp/run-stage")
            if sit:
                argv.append("--sit")
            argv.append("/tmp/stage")

            options_str = json.dumps(options, indent=2)

            print()
            print(f"{RESET}{BOLD}{i}. {name}{RESET} {options_str}")
            print("Inspect with:")
            print(f"\t# nsenter -a --wd=/root -t `machinectl show {machine_name} -p Leader --value`")
            print()

            try:
                subprocess.run(argv,
                    input=options_str, encoding="utf-8",
                    stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT,
                    check=True)
            except KeyboardInterrupt:
                print()
                print(f"{RESET}{BOLD}{RED}Aborted{RESET}")
                return 130
            except subprocess.CalledProcessError as error:
                print()
                print(f"{RESET}{BOLD}{RED}{name} failed with code {error.returncode}{RESET}")
                return 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Build operating system images")
    parser.add_argument("pipeline_path", metavar="PIPELINE",
                        help="json file containing the pipeline that should be built")
    parser.add_argument("--input", dest="input_dir", metavar="DIRECTORY",
                        help="provide the contents of DIRECTORY to the first stage")
    parser.add_argument("--output", dest="output_dir", metavar="DIRECTORY",
                        help="provide the empty DIRECTORY as output argument to the last stage")
    parser.add_argument("--sit", action="store_true",
                        help="keep the build environment up when a stage failed")
    args = parser.parse_args()

    sys.exit(main(**vars(args)))
